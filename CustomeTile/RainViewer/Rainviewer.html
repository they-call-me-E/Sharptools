<!-- Do not edit below -->
<script type="application/json" id="tile-settings">
{
  "schema": "0.2.0",
  "settings": [
    {"name": "mToken", "label": "Mapbox Access Token", "type": "STRING"},
    {"type": "STRING", "name": "mLat", "label": "Map Zone Latitude "},
    {"type": "STRING", "name": "mLon", "label": "Map Zone Longitude "},
    {
      "name": "mZoom",
      "label": "Map Zone Zoom Level (0-22) 0 = Zoomed Out, 22 = Zoomed In",
      "type": "NUMBER"
    },
    {"type": "NUMBER", "name": "wStyle", "label": "Weather Style (0-11)"},
    {
      "type": "NUMBER",
      "name": "mStyle",
      "label": "Map Style (1: Streets, 2: Light, 3: Dark, 4: Satellite)"
    },
    {"type": "STRING", "name": "statesAlerts", "label": "NC  or NC,SC,GA,TN"}
  ],
  "name": "Rain Viewer",
  "dimensions": {"height": 3, "width": 3}
}
</script>
<!-- Do not edit above -->

<style>
    /* MAPBOX AND LAYOUT STYLES */
    .mapboxgl-ctrl-attrib.mapboxgl-compact {
        display: none !important;
    }

    .mapboxgl-ctrl {
        display: none !important;
    }

    #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
        left: 0;
        border-radius: 10px;
        /* Added border-radius */
    }

    #animationProgress {
        position: absolute;
        left: 80px;
        bottom: 25px;
        height: 6px;
        width: calc(100% - 170px);
        background-color: #ccc;
        border-radius: 3px;
        z-index: 10;
    }

    #progressDot {
        position: absolute;
        top: 50%;
        width: 12px;
        height: 12px;
        background-color: grey;
        border-radius: 50%;
        transform: translateY(-50%);
    }

    .mapboxgl-popup-content {
        color: black;
        background-color: rgba(0, 0, 0, 0.7);
        border-radius: 6px;
        padding: 8px;
    }

    .popup-divider {
        margin: 8px 0;
        border: none;
        border-top: 1px solid #ccc;
    }

    .popup-description {
        display: none;
        max-height: 100px;
        overflow-y: auto;
        margin-top: 4px;
    }

    .popup-more-link {
        float: right;
        cursor: pointer;
        color: blue;
        text-decoration: underline;
        margin-top: 5px;
    }

    /* NEW: Time display overlay style */
    #timeDisplay {
        position: absolute;
        bottom: 10px;
        right: 10px;
        padding: 5px 10px;
        border-radius: 3px;
        font-family: Arial, sans-serif;
        font-size: 16px;
        z-index: 10;
    }

    /* NEW: Spinner overlay style */
    #spinner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 20;
        width: 50px;
        height: 50px;
        border: 8px solid #f3f3f3;
        border-top: 8px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% {
            transform: translate(-50%, -50%) rotate(0deg);
        }

        100% {
            transform: translate(-50%, -50%) rotate(360deg);
        }
    }

    /* FANCY PLAY/PAUSE BUTTON STYLES */
    .play,
    .play::before,
    .play::after {
        width: 100px;
        height: 100px;
        transition: 0.15s ease;
    }

    .play {
        overflow: hidden;
        position: absolute;
        bottom: -20px;
        left: 0;
        border-radius: 25px;
        transform: scale(0.25) translate(-32px, 0px) rotate(120deg) skewY(30deg) scaleX(0.866);
        transition: 0.35s cubic-bezier(0.5, 2, 0.7, 1);
    }

    .play:active {
        transform: scale(0.25) translate(-22px, 0px) rotate(120deg) skewY(30deg) scaleX(0.606) scaleY(0.7);
    }

    .play::before,
    .play::after {
        content: "";
        position: absolute;
        background: white;
        cursor: pointer;
    }

    .play::before {
        border-radius: 25px 25px 25px 50px;
        transform: scaleX(1.1555) skewY(-30deg) rotate(-30deg) translate(-24px, -42px) skewX(30deg) scaleY(0.8666);
    }

    .play::after {
        border-radius: 25px 25px 50px 25px;
        transform: scaleX(1.1555) skewY(-30deg) rotate(-30deg) translate(24px, -42px) skewX(-30deg) scaleY(0.8666);
    }

    .play.paused {
        transform: scale(0.25) translate(-7px, 0px) rotate(90deg) skewY(0deg) scaleX(1);
        cursor: pointer;
    }

    .play.paused:active {
        transform: scale(0.25) translate(-7px, 0px) rotate(90deg) skewY(0deg) scale(0.7);
    }

    .play.paused::before {
        height: 85px;
        width: 30px;
        transform: scale(1) skewY(0deg) rotate(-90deg) translate(21px, 35px) skewX(0deg);
        border-radius: 10px;
    }

    .play.paused::after {
        height: 85px;
        width: 30px;
        transform: scale(1) skewY(0deg) rotate(-90deg) translate(-21px, 35px) skewX(0deg);
        border-radius: 10px;
    }

    /* === NEW: Slide-in Menu Styles === */
    #menuButton {
        position: fixed;
        top: 10px;
        right: 20px;
        z-index: 60;
        background: white;
        border: none;
        cursor: pointer;
        padding: 0px;
        border-radius: 3px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    #menuButton svg {
        width: 24px;
        height: 24px;
        fill: black;
    }

    #sideMenu {
        position: fixed;
        top: 0;
        right: 0;
        width: 250px;
        max-height: 100vh;
        background: white;
        color: black;
        box-shadow: -2px 0 5px rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        z-index: 50;
        padding: 20px;
        padding-bottom: 40px;
        overflow-y: auto;
        box-sizing: border-box;
    }

    #sideMenu.open {
        transform: translateX(0);
    }

    #sideMenu h3 {
        margin-top: 0;
        margin-bottom: 15px;
    }

    #sideMenu h4 {
        margin-bottom: 10px;
    }

    #sideMenu label {
        display: block;
        margin-bottom: 10px;
        font-size: 16px;
    }

    /* === NEW: Slider Styles for Opacity and Animation Speed === */
    input[type="range"] {
        -webkit-appearance: none;
        width: 100%;
        margin: 10px 0;
        position: relative;
        top: -15px;
    }

    input[type="range"]:focus {
        outline: none;
    }

    input[type="range"]::-webkit-slider-runnable-track {
        height: 6px;
        background: #ddd;
        border: none;
        border-radius: 3px;
    }

    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background: #3498db;
        margin-top: -5px;
        cursor: pointer;
    }

    /* Slider labels container */
    .slider-labels {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: #333;
        position: relative;
        top: -42px;
        padding: 0 0px;
        left: -10px
    }

    /* Add extra space between the labels by adding margin to the middle label */
    .slider-labels span:nth-child(2) {
        margin: 0 69px;
    }

    /* Tick marks for the Animation Speed slider */
    #menuSpeed {
        position: relative;
        padding-bottom: 20px;
        top: -15px;
    }

    #menuSpeed::before {
        content: "";
        position: absolute;
        bottom: 16px;
        left: 0;
        right: 0;
        height: 15px;
        background-repeat: no-repeat;
        background-size: 1px 18px;
        background-image:
            linear-gradient(to right, black 1px, transparent 1px),
            linear-gradient(to right, black 1px, transparent 1px),
            linear-gradient(to right, black 1px, transparent 1px),
            linear-gradient(to right, black 1px, transparent 1px),
            linear-gradient(to right, black 1px, transparent 1px);
        background-position: 0% 0, 25% 0, 50% 0, 75% 0, 100% 0;
        pointer-events: none;
        z-index: 1;
    }

    #menuSpeed::-webkit-slider-thumb {
        position: relative;
        z-index: 2;
    }

    /* === NEW: Fly-out Panel for Alert Types === */
    /* Backdrop overlay (semi-transparent) */
    /* Backdrop overlay: completely hidden when not open */
    #alertFlyoutBackdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.3);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease;
        z-index: 99;
    }

    #alertFlyoutBackdrop.open {
        opacity: 1;
        visibility: visible;
    }

    /* Fly–out panel for Alert Types */
    #alertFlyoutPanel {
        position: fixed;
        top: 0;
        right: 0;
        width: 300px;
        height: 325px;
        border-radius: 10px;
        background: #f1f1f1;
        color: black;
        box-shadow: -2px 0 5px rgba(0, 0, 0, 0.3);
        transform: translateX(100%);
        /* Completely off–screen when closed */
        transition: transform 0.3s ease;
        z-index: 100;
        padding: 20px;
        overflow-y: auto;
    }

    #alertFlyoutPanel.open {
        transform: translateX(0);
    }

    /* Close button in the fly-out panel */
    #alertFlyoutPanel .closeBtn {
        position: absolute;
        top: 10px;
        right: 10px;
        cursor: pointer;
        font-size: 18px;
    }
</style>

<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1,maximum-scale=1">
<!-- Mapbox GL JS v2.x -->
<script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
<script src="//cdn.sharptools.io/js/custom-tiles.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<!-- === NEW: Menu Button and Side Menu Markup === -->
<button id="menuButton" title="Layers">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M3 13h18v-2H3v2zm0 4h18v-2H3v2zm0-10v2h18V7H3z"></path>
    </svg>
</button>
<div id="sideMenu">
    <h3>Map Settings</h3>
    <label><input type="checkbox" id="menuCounties" checked=""> Counties</label>
    <label><input type="checkbox" id="menuArrows" checked=""> Arrows</label>
    <!-- Alerts checkbox with a fly-out trigger button next to it -->
    <label>
        <input type="checkbox" id="menuAlerts" checked=""> Alerts
        <button id="alertFlyoutBtn" title="..." style="font-size:14px; margin-left:5px;">Alert Types</button>
    </label>
    <!-- Radar Opacity Slider -->
    <label for="menuOpacity">Radar Opacity</label>
    <input type="range" id="menuOpacity" min="0" max="1" step="0.01" value="1">
    <!-- Animation Speed Slider -->
    <label for="menuSpeed">Animation Speed</label>
    <input type="range" id="menuSpeed" min="1" max="5" step="1" value="3">
    <div class="slider-labels">
        <span class="slow">Slow</span>
        <span class="medium">Medium</span>
        <span class="fast">Fast</span>
    </div>
</div>

<!-- Fly-out panel for Alert Types -->
<div id="alertFlyoutBackdrop"></div>
<div id="alertFlyoutPanel">
    <span class="closeBtn" id="alertFlyoutClose">X</span>
    <h4>Alert Types</h4>
    <div id="flyoutAlertFilters"></div>
</div>

<div id="map"></div>
<!-- Spinner overlay; visible until preloading is complete -->
<div id="spinner"></div>
<!-- Fancy play/pause button -->
<div class="play" id="playPauseBtn"></div>
<!-- Time display overlay -->
<div id="timeDisplay"></div>
<!-- Animation progress bar -->
<div id="animationProgress">
    <div id="progressDot"></div>
</div>

<script>
    /* NOAA ALERT COLORS */
    const ALERT_COLORS = {
        "Tornado Warning": "red",
        "Severe Thunderstorm Warning": "orange",
        "Flash Flood Warning": "darkgreen",
        "Hurricane Warning": "purple",
        "Tropical Storm Warning": "blue",
        "Tornado Watch": "yellow",
        "Severe Thunderstorm Watch": "yellow",
        "Hurricane Watch": "plum",
        "Tropical Storm Watch": "lightblue",
        "Flood Warning": "darkgreen",
        "Flood Watch": "lightgreen",
        "Coastal Flood Warning": "teal",
        "Coastal Flood Watch": "lightseagreen",
        "Winter Storm Warning": "pink",
        "Winter Storm Watch": "lightpink",
        "Blizzard Warning": "white",
        "Wind Chill Warning": "lightblue",
        "High Wind Warning": "brown",
        "Wind Advisory": "tan",
        "Heat Advisory": "orange",
        "Excessive Heat Warning": "darkorange",
        "Fire Weather Warning": "red",
        "Special Marine Warning": "blue",
        "Air Quality Alert": "gray",
        "Special Weather Statement": "lightgray",
        "default": "gray"
    };
    const stateNameToAbbr = {
        "Alabama": "AL",
        "Alaska": "AK",
        "Arizona": "AZ",
        "Arkansas": "AR",
        "California": "CA",
        "Colorado": "CO",
        "Connecticut": "CT",
        "Delaware": "DE",
        "District of Columbia": "DC",
        "Florida": "FL",
        "Georgia": "GA",
        "Hawaii": "HI",
        "Idaho": "ID",
        "Illinois": "IL",
        "Indiana": "IN",
        "Iowa": "IA",
        "Kansas": "KS",
        "Kentucky": "KY",
        "Louisiana": "LA",
        "Maine": "ME",
        "Maryland": "MD",
        "Massachusetts": "MA",
        "Michigan": "MI",
        "Minnesota": "MN",
        "Mississippi": "MS",
        "Missouri": "MO",
        "Montana": "MT",
        "Nebraska": "NE",
        "Nevada": "NV",
        "New Hampshire": "NH",
        "New Jersey": "NJ",
        "New Mexico": "NM",
        "New York": "NY",
        "North Carolina": "NC",
        "North Dakota": "ND",
        "Ohio": "OH",
        "Oklahoma": "OK",
        "Oregon": "OR",
        "Pennsylvania": "PA",
        "Rhode Island": "RI",
        "South Carolina": "SC",
        "South Dakota": "SD",
        "Tennessee": "TN",
        "Texas": "TX",
        "Utah": "UT",
        "Vermont": "VT",
        "Virginia": "VA",
        "Washington": "WA",
        "West Virginia": "WV",
        "Wisconsin": "WI",
        "Wyoming": "WY",
        "Puerto Rico": "PR"
    };

    /* ANIMATION VARIABLES */
    let animationIntervalMS = 1500; // Default mapped to step 3 ("Medium")
    const FADE_DURATION_MS = 150;
    const INITIAL_FADE_MS = 600;

    /* MAP + RADAR SETUP VARIABLES */
    let mLat = 35;
    let mLon = -83;
    let mZoom = 5;
    let radarFrames = [];
    let radarFrameTimes = [];
    let currentFrameIndex = 0;
    let mToken;
    let wStyle = 1;
    let mStyle = "mapbox://styles/mapbox/dark-v11";
    let stateAlerts = "NC";
    let map;

    // Global toggles
    let showCounties = true;
    let showAlerts = false;
    let showArrows = true;
    let alertLayerIds = [];

    document.getElementById('menuAlerts').checked = showAlerts;
    document.getElementById('menuCounties').checked = showCounties;

    // Global object to filter alert types (excluding "default")
    const alertTypeFilters = {};
    Object.keys(ALERT_COLORS).forEach(key => {
        if (key !== "default") { alertTypeFilters[key] = true; }
    });

    let isPlaying = false;
    let activeBuffer = "A";
    let autoPlay = true;
    let radarOpacity = 1;

    // Radar opacity slider event
    document.getElementById('menuOpacity').addEventListener('input', (e) => {
        radarOpacity = parseFloat(e.target.value);
        if (map) {
            if (map.getLayer("radarLayerA")) {
                map.setPaintProperty("radarLayerA", "raster-opacity", radarOpacity);
            }
            if (map.getLayer("radarLayerB")) {
                map.setPaintProperty("radarLayerB", "raster-opacity", radarOpacity);
            }
        }
    });

    // Animation speed slider event
    document.getElementById('menuSpeed').addEventListener('input', (e) => {
        const stepValue = parseInt(e.target.value, 10);
        switch (stepValue) {
            case 1: animationIntervalMS = 2500; break;
            case 2: animationIntervalMS = 2000; break;
            case 3: animationIntervalMS = 1500; break;
            case 4: animationIntervalMS = 1000; break;
            case 5: animationIntervalMS = 500; break;
        }
        if (animationInterval) {
            clearInterval(animationInterval);
            animateRadar();
        }
    });

    const END_OF_LOOP_PAUSE_MS = 2000;
    let pauseActive = false;
    let pauseStartTime = 0;
    let framesLoadedCount = 0;
    let animationInterval;

    // --- Fly-out Panel Functionality for Alert Types ---
    document.getElementById('alertFlyoutBtn').addEventListener('click', function (e) {
        e.stopPropagation();
        document.getElementById('alertFlyoutBackdrop').classList.add('open');
        document.getElementById('alertFlyoutPanel').classList.add('open');
        // Build alert filters into the fly-out panel
        const flyoutContainer = document.getElementById('flyoutAlertFilters');
        flyoutContainer.innerHTML = '';
        Object.keys(alertTypeFilters).forEach(alertType => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.style.marginBottom = '8px';
            label.style.fontSize = '14px';
            label.style.verticalAlign = 'middle';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = alertTypeFilters[alertType];
            checkbox.setAttribute('data-type', alertType);
            checkbox.style.verticalAlign = 'middle';
            checkbox.addEventListener('change', (e) => {
                const type = e.target.getAttribute('data-type');
                alertTypeFilters[type] = e.target.checked;
                removeAllAlertLayers();
                if (showAlerts) { fetchNoaaAlerts(); }
            });
            label.appendChild(checkbox);
            const colorBox = document.createElement('span');
            colorBox.style.width = '16px';
            colorBox.style.height = '16px';
            colorBox.style.display = 'inline-block';
            colorBox.style.backgroundColor = ALERT_COLORS[alertType] || 'transparent';
            colorBox.style.margin = '0 5px';
            colorBox.style.verticalAlign = 'middle';
            label.appendChild(colorBox);
            label.appendChild(document.createTextNode(alertType));
            flyoutContainer.appendChild(label);
        });
    });
    document.getElementById('alertFlyoutClose').addEventListener('click', function () {
        document.getElementById('alertFlyoutBackdrop').classList.remove('open');
        document.getElementById('alertFlyoutPanel').classList.remove('open');
    });
    document.getElementById('alertFlyoutBackdrop').addEventListener('click', function () {
        document.getElementById('alertFlyoutBackdrop').classList.remove('open');
        document.getElementById('alertFlyoutPanel').classList.remove('open');
    });
    document.addEventListener('click', function (e) {
        const panel = document.getElementById('alertFlyoutPanel');
        const backdrop = document.getElementById('alertFlyoutBackdrop');
        if (panel.classList.contains('open') && !panel.contains(e.target) && e.target.id !== 'alertFlyoutBtn') {
            panel.classList.remove('open');
            backdrop.classList.remove('open');
        }
    });
    // --- End Fly-out Panel Functionality ---

    stio.ready((data) => {
        if (data.settings.mToken) {
            mToken = data.settings.mToken;
            if (typeof data.settings.mLat === 'string') mLat = parseFloat(data.settings.mLat);
            if (typeof data.settings.mLon === 'string') mLon = parseFloat(data.settings.mLon);
            if (isNaN(mLat) || isNaN(mLon)) {
                console.error('Error: Invalid lat/lon');
                return;
            }
            mZoom = data.settings.mZoom || mZoom;
            wStyle = data.settings.wStyle || wStyle;
            stateAlerts = data.settings.statesAlerts || stateAlerts;
            if (data.settings.mStyle == 1) mStyle = "mapbox://styles/mapbox/streets-v12";
            if (data.settings.mStyle == 2) mStyle = "mapbox://styles/mapbox/light-v11";
            if (data.settings.mStyle == 3) mStyle = "mapbox://styles/mapbox/dark-v11";
            if (data.settings.mStyle == 4) mStyle = "mapbox://styles/mapbox/satellite-v9";
            mapboxgl.accessToken = mToken;
            initializeMap();
            buildAlertFilters();
        }
    });

    function buildAlertFilters() {
        const container = document.getElementById('alertFilters');
        container.innerHTML = '';
        Object.keys(alertTypeFilters).forEach(alertType => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.style.marginBottom = '8px';
            label.style.fontSize = '14px';
            label.style.verticalAlign = 'middle';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = alertTypeFilters[alertType];
            checkbox.setAttribute('data-type', alertType);
            checkbox.style.verticalAlign = 'middle';
            checkbox.addEventListener('change', (e) => {
                const type = e.target.getAttribute('data-type');
                alertTypeFilters[type] = e.target.checked;
                removeAllAlertLayers();
                if (showAlerts) { fetchNoaaAlerts(); }
            });
            label.appendChild(checkbox);
            const colorBox = document.createElement('span');
            colorBox.style.width = '16px';
            colorBox.style.height = '16px';
            colorBox.style.display = 'inline-block';
            colorBox.style.backgroundColor = ALERT_COLORS[alertType] || 'transparent';
            colorBox.style.margin = '0 5px';
            colorBox.style.verticalAlign = 'middle';
            label.appendChild(colorBox);
            label.appendChild(document.createTextNode(alertType));
            container.appendChild(label);
        });
    }

    async function initializeMap() {
        map = new mapboxgl.Map({
            container: "map",
            style: mStyle,
            center: [mLon, mLat],
            zoom: mZoom
        });
        new mapboxgl.Marker().setLngLat([mLon, mLat]).addTo(map);
        map.on('load', () => {
            const arrowUrl = 'https://raw.githubusercontent.com/they-call-me-E/Sharptools/main/CustomeTile/RainViewer/arrow1.png';
            map.loadImage(arrowUrl, (err, image) => {
                if (err) {
                    console.error("Error loading arrow icon:", err);
                    return;
                }
                if (!map.hasImage('arrow-icon')) {
                    map.addImage('arrow-icon', image);
                    console.log("Arrow icon loaded successfully.");
                }
            });
        });
        map.on("styleimagemissing", (e) => {
            if (e.id === "arrow-icon") {
                const arrowUrl = 'https://raw.githubusercontent.com/they-call-me-E/Sharptools/main/CustomeTile/RainViewer/arrow1.png';
                map.loadImage(arrowUrl, (err, image) => {
                    if (err) {
                        console.error("Error loading arrow icon on styleimagemissing:", err);
                        return;
                    }
                    if (!map.hasImage('arrow-icon')) {
                        map.addImage('arrow-icon', image);
                        console.log("Arrow icon loaded via styleimagemissing.");
                    }
                });
            }
        });
        map.on('moveend', () => {
            const closestAbbrs = getClosestStateAbbreviations(3);
            stateAlerts = closestAbbrs.join(',');
            removeAllAlertLayers();
            fetchNoaaAlerts();
        });
        map.on("load", async () => {
            addStatesLayer();
            if (showCounties) { addCountiesLayer(); }
            await fetchRadarData();
            await fetchNoaaAlerts();
            preloadAllFrames(radarFrames, () => {
                document.getElementById("spinner").style.display = "none";
                setupBuffers();
                map.once("idle", () => {
                    fadeLayerIn("radarLayerA", INITIAL_FADE_MS);
                    updateTimeDisplay(currentFrameIndex);
                });
                if (autoPlay) {
                    animateRadar(); // Starts animation and sets button to pause symbol
                } else {
                    playPauseBtn.classList.add('paused'); // Ensure play symbol if not auto-playing
                }
            });
            setInterval(fetchRadarData, 300000);
        });
    }

    // Set initial state based on autoPlay
    const playPauseBtn = document.getElementById('playPauseBtn');
    if (autoPlay) {
        playPauseBtn.classList.add('paused'); // Pause symbol (playing)
    } else {
        playPauseBtn.classList.remove('paused'); // Play symbol (paused)
    }

    // Toggle play/pause on click
    playPauseBtn.addEventListener('click', () => {
        if (playPauseBtn.classList.contains('paused')) {
            // Switch to paused (show play symbol)
            playPauseBtn.classList.remove('paused');
            isPlaying = false;
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        } else {
            // Switch to playing (show pause symbol)
            playPauseBtn.classList.add('paused');
            isPlaying = true;
            if (!animationInterval) {
                animateRadar();
            }
        }
    });

    document.getElementById('menuArrows').addEventListener('change', (e) => {
        showArrows = e.target.checked;
        if (map.getLayer("arrowLayer")) {
            map.setLayoutProperty("arrowLayer", "visibility", showArrows ? "visible" : "none");
        }
    });

    async function fetchRadarData() {
        try {
            const url = "https://api.rainviewer.com/public/weather-maps.json?past_hours=6";
            const response = await fetch(url);
            const apiData = await response.json();
            const pastFrames = apiData.radar.past.map(frame =>
                `${apiData.host}${frame.path}/256/{z}/{x}/{y}/${wStyle}/1_1.png`
            );
            const pastFrameTimes = apiData.radar.past.map(frame => frame.time);
            const nowcastFrames = apiData.radar.nowcast.map(frame =>
                `${apiData.host}${frame.path}/256/{z}/{x}/{y}/${wStyle}/1_1.png`
            );
            const nowcastFrameTimes = apiData.radar.nowcast.map(frame => frame.time);
            radarFrames = pastFrames.concat(nowcastFrames);
            radarFrameTimes = pastFrameTimes.concat(nowcastFrameTimes);
            console.log("Radar frames loaded:", radarFrames.length);
        } catch (err) {
            console.error("Error fetching radar data:", err);
        }
    }

    function preloadAllFrames(urls, onComplete) {
        if (!urls.length) { onComplete(); return; }
        framesLoadedCount = 0;
        urls.forEach((url) => {
            const img = new Image();
            img.src = url + `?preload=${Date.now()}`;
            img.onload = () => {
                framesLoadedCount++;
                if (framesLoadedCount === urls.length) { onComplete(); }
            };
            img.onerror = () => {
                framesLoadedCount++;
                if (framesLoadedCount === urls.length) { onComplete(); }
            };
        });
    }

    function setupBuffers() {
        if (radarFrames.length) {
            createRadarLayer("radarSourceA", "radarLayerA", radarFrames[0], 0);
        }
        createRadarLayer("radarSourceB", "radarLayerB", radarFrames.length ? radarFrames[0] : "", 0);
        updateProgressBar(0);
    }

    function createRadarLayer(sourceId, layerId, tileUrl, initOpacity) {
        if (map.getLayer(layerId)) { map.removeLayer(layerId); }
        if (map.getSource(sourceId)) { map.removeSource(sourceId); }
        if (!tileUrl) return;
        map.addSource(sourceId, {
            type: 'raster',
            tiles: [tileUrl],
            tileSize: 256,
            minzoom: 0,
            maxzoom: 12
        });
        map.addLayer({
            id: layerId,
            type: 'raster',
            source: sourceId,
            paint: { 'raster-opacity': initOpacity }
        });
    }

    function fadeLayerIn(layerId, durationMs) {
        const startTime = performance.now();
        function step(now) {
            const elapsed = now - startTime;
            const fraction = Math.min(elapsed / durationMs, 1);
            if (map.getLayer(layerId)) {
                map.setPaintProperty(layerId, 'raster-opacity', fraction * radarOpacity);
            }
            if (fraction < 1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
    }

    // Animation function (ensure button state stays in sync)
    function animateRadar() {
        if (radarFrames.length < 2) return;
        // Ensure button shows pause symbol when animation starts
        playPauseBtn.classList.add('paused');
        isPlaying = true;
        animationInterval = setInterval(() => {
            if (!isPlaying) {
                clearInterval(animationInterval);
                animationInterval = null;
                playPauseBtn.classList.remove('paused'); // Show play symbol when stopped
                return;
            }
            if (pauseActive) {
                if (Date.now() - pauseStartTime >= END_OF_LOOP_PAUSE_MS) {
                    pauseActive = false;
                } else {
                    return;
                }
            }
            crossfadeNextFrame();
            updateProgressBar(currentFrameIndex);
            updateTimeDisplay(currentFrameIndex);
            if (currentFrameIndex === radarFrames.length - 1) {
                pauseActive = true;
                pauseStartTime = Date.now();
            }
            currentFrameIndex = (currentFrameIndex + 1) % radarFrames.length;
        }, animationIntervalMS);
    }

    function crossfadeNextFrame() {
        const oldBuf = activeBuffer;
        const newBuf = (oldBuf === "A") ? "B" : "A";
        const oldLayerId = "radarLayer" + oldBuf;
        const newLayerId = "radarLayer" + newBuf;
        const newSourceId = "radarSource" + newBuf;
        const frameUrl = radarFrames[currentFrameIndex];
        createRadarLayer(newSourceId, newLayerId, frameUrl, 0);
        map.once("idle", () => {
            fadeLayers(oldLayerId, newLayerId, FADE_DURATION_MS);
        });
        activeBuffer = newBuf;
        if (showArrows) {
            let nextIndex = (currentFrameIndex + 1) % radarFrames.length;
            computeAndDisplayArrows(radarFrames[currentFrameIndex], radarFrames[nextIndex]);
        }
    }

    function fadeLayers(layerOut, layerIn, durationMs) {
        const startTime = performance.now();
        function step(now) {
            const elapsed = now - startTime;
            const fraction = Math.min(elapsed / durationMs, 1);
            if (map.getLayer(layerOut)) {
                map.setPaintProperty(layerOut, 'raster-opacity', (1 - fraction) * radarOpacity);
            }
            if (map.getLayer(layerIn)) {
                map.setPaintProperty(layerIn, 'raster-opacity', fraction * radarOpacity);
            }
            if (fraction < 1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
    }

    function updateProgressBar(frameIndex) {
        const progressBar = document.getElementById('animationProgress');
        const dot = document.getElementById('progressDot');
        if (!radarFrames || radarFrames.length < 2) {
            dot.style.left = '0px';
            return;
        }
        const available = progressBar.clientWidth - dot.clientWidth;
        const fraction = frameIndex / (radarFrames.length - 1);
        dot.style.left = (fraction * available) + "px";
    }

    function updateTimeDisplay(frameIndex) {
        if (radarFrameTimes.length > 0) {
            let timestamp = radarFrameTimes[frameIndex];
            let date = new Date(timestamp * 1000);
            let options = { hour: 'numeric', minute: 'numeric', hour12: true };
            let timeString = date.toLocaleTimeString([], options);
            document.getElementById("timeDisplay").textContent = timeString;
        }
    }

    async function fetchNoaaAlerts() {
        if (!showAlerts) return;
        document.getElementById('spinner').style.display = 'block';
        const alertUrl = `https://api.weather.gov/alerts/active?area=${stateAlerts}`;
        try {
            const response = await fetch(alertUrl);
            const data = await response.json();
            if (!data.features) {
                console.log("No NOAA alerts found for:", stateAlerts);
                return;
            }
            for (const feature of data.features) {
                const eventType = feature.properties.event || "default";
                if (!alertTypeFilters[eventType]) continue;
                const alertColor = ALERT_COLORS[eventType] || ALERT_COLORS["default"];
                const headline = feature.properties.headline || "N/A";
                const updatedProps = { ...feature.properties, fillColor: alertColor, myHeadline: headline };
                const newFeature = { ...feature, properties: updatedProps };
                if (newFeature.geometry) {
                    addAlertPolygon(newFeature, alertColor);
                } else {
                    const zones = newFeature.properties.affectedZones || [];
                    for (const zoneUrl of zones) {
                        await fetchZoneGeometry(zoneUrl, newFeature, alertColor);
                    }
                }
            }
        } catch (err) {
            console.error("Error fetching NOAA alerts:", err);
        } finally {
            document.getElementById('spinner').style.display = 'none';
        }
    }

    function addAlertPolygon(feature, color) {
        const simplifiedFeature = turf.simplify(feature, { tolerance: 0.01, highQuality: false });
        const alertId = simplifiedFeature.id || ("alert-" + Math.random());
        alertLayerIds.push(alertId);
        map.addSource(alertId, {
            type: "geojson",
            data: { type: "FeatureCollection", features: [simplifiedFeature] }
        });
        map.addLayer({
            id: alertId,
            type: "fill",
            source: alertId,
            paint: { "fill-color": color, "fill-opacity": 0.3 }
        });
        map.addLayer({
            id: alertId + "-border",
            type: "line",
            source: alertId,
            paint: { "line-color": color, "line-width": 2 }
        });
        map.on("click", alertId, (e) => {
            const props = e.features[0].properties;
            showAlertPopup(e.lngLat, props);
        });
    }

    async function fetchZoneGeometry(zoneUrl, parentFeature, color) {
        try {
            const resp = await fetch(zoneUrl);
            const data = await resp.json();
            if (!data.geometry) {
                console.log("No geometry for zone:", zoneUrl);
                return;
            }
            let zoneFeature = {
                type: "Feature",
                geometry: data.geometry,
                properties: { ...parentFeature.properties }
            };
            zoneFeature = turf.simplify(zoneFeature, { tolerance: 0.01, highQuality: false });
            const zoneId = (parentFeature.id || "alert-") + "-" + data.id;
            alertLayerIds.push(zoneId);
            map.addSource(zoneId, {
                type: "geojson",
                data: { type: "FeatureCollection", features: [zoneFeature] }
            });
            map.addLayer({
                id: zoneId,
                type: "fill",
                source: zoneId,
                paint: { "fill-color": color, "fill-opacity": 0.3 }
            });
            map.addLayer({
                id: zoneId + "-border",
                type: "line",
                source: zoneId,
                paint: { "line-color": color, "line-width": 2 }
            });
            map.on("click", zoneId, (e) => {
                const props = e.features[0].properties;
                showAlertPopup(e.lngLat, props);
            });
        } catch (err) {
            console.error("Error fetching zone geometry for", zoneUrl, err);
        }
    }

    function showAlertPopup(lngLat, props) {
        const headline = props.myHeadline || "N/A";
        const descriptionFull = props.description || "No further details provided.";
        const popupContent = document.createElement('div');
        popupContent.innerHTML = `<strong>${headline}</strong>`;
        const divider = document.createElement('hr');
        divider.className = 'popup-divider';
        divider.style.display = 'none';
        popupContent.appendChild(divider);
        const descDiv = document.createElement('div');
        descDiv.className = 'popup-description';
        descDiv.textContent = descriptionFull;
        popupContent.appendChild(descDiv);
        const toggleLink = document.createElement('span');
        toggleLink.className = 'popup-more-link';
        toggleLink.textContent = 'More';
        if (descriptionFull.trim() && descriptionFull !== 'No further details provided.') {
            toggleLink.addEventListener('click', () => {
                if (descDiv.style.display === 'none') {
                    descDiv.style.display = 'block';
                    divider.style.display = 'block';
                    toggleLink.textContent = 'Less';
                } else {
                    descDiv.style.display = 'none';
                    divider.style.display = 'none';
                    toggleLink.textContent = 'More';
                }
            });
        } else {
            toggleLink.style.display = 'none';
        }
        popupContent.appendChild(toggleLink);
        new mapboxgl.Popup().setLngLat(lngLat).setDOMContent(popupContent).addTo(map);
    }

    document.getElementById('menuButton').addEventListener('click', () => {
        document.getElementById('sideMenu').classList.toggle('open');
    });
    document.getElementById('menuCounties').addEventListener('change', (e) => {
        showCounties = e.target.checked;
        if (showCounties) {
            addCountiesLayer();
        } else {
            if (map.getLayer("counties-layer")) map.removeLayer("counties-layer");
            if (map.getSource("counties")) map.removeSource("counties");
        }
    });

    function removeAllAlertLayers() {
        alertLayerIds.forEach(id => {
            if (map.getLayer(id)) map.removeLayer(id);
            if (map.getLayer(id + "-border")) map.removeLayer(id + "-border");
            if (map.getSource(id)) map.removeSource(id);
        });
        alertLayerIds = [];
    }

    function addCountiesLayer() {
        fetch("https://raw.githubusercontent.com/they-call-me-E/Sharptools/refs/heads/main/CustomeTile/RainViewer/counties.json")
            .then(response => response.json())
            .then(countiesData => {
                if (map.getLayer("counties-layer")) map.removeLayer("counties-layer");
                if (map.getSource("counties")) map.removeSource("counties");
                map.addSource("counties", { type: "geojson", data: countiesData });
                map.addLayer({
                    id: "counties-layer",
                    type: "line",
                    source: "counties",
                    layout: {},
                    paint: {
                        "line-color": "#aaaaaa",
                        "line-width": 2,
                        "line-opacity": 0.125
                    }
                });
            })
            .catch(err => console.error("Error loading counties GeoJSON:", err));
    }
    function addStatesLayer() {
        fetch("https://raw.githubusercontent.com/they-call-me-E/Sharptools/refs/heads/main/CustomeTile/RainViewer/states.json")
            .then(response => response.json())
            .then(statesData => {
                if (map.getLayer("states-layer")) map.removeLayer("states-layer");
                if (map.getSource("states")) map.removeSource("states");
                map.addSource("states", { type: "geojson", data: statesData });
                map.addLayer({
                    id: "states-layer",
                    type: "line",
                    source: "states",
                    layout: {},
                    paint: {
                        "line-color": "#aaaaaa",
                        "line-width": 2,
                        "line-opacity": 0.5
                    }
                });
            })
            .catch(err => console.error("Error loading states GeoJSON:", err));
    }
    function getClosestStateAbbreviations(numStates = 3) {
        numStates = Math.max(1, Math.min(numStates, 4));
        const center = map.getCenter();
        const centerPoint = turf.point([center.lng, center.lat]);
        const features = map.queryRenderedFeatures({ layers: ['states-layer'] });
        const featuresWithDistance = features.map(feature => {
            const name = feature.properties && feature.properties.name;
            if (!name) return null;
            const abbr = stateNameToAbbr[name] || name;
            const centroid = turf.centroid(feature);
            const distance = turf.distance(centerPoint, centroid, { units: 'kilometers' });
            return { abbr, distance };
        }).filter(item => item !== null);
        const uniqueStates = {};
        featuresWithDistance.forEach(item => {
            if (!uniqueStates[item.abbr] || uniqueStates[item.abbr].distance > item.distance) {
                uniqueStates[item.abbr] = item;
            }
        });
        const sortedStates = Object.values(uniqueStates).sort((a, b) => a.distance - b.distance);
        return sortedStates.slice(0, numStates).map(item => item.abbr);
    }
    function lng2tile(lon, zoom) {
        return Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
    }
    function lat2tile(lat, zoom) {
        return Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
    }
    function tile2lng(x, zoom) {
        return x / Math.pow(2, zoom) * 360 - 180;
    }
    function tile2lat(y, zoom) {
        var n = Math.PI - 2 * Math.PI * y / Math.pow(2, zoom);
        return 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    }
    function getTileUrl(template, zoom, x, y) {
        return template.replace('{z}', zoom).replace('{x}', x).replace('{y}', y);
    }
    function computeAndDisplayArrows(currentFrameUrlTemplate, nextFrameUrlTemplate) {
        let center = map.getCenter();
        let zoom = Math.floor(map.getZoom());
        let tileX = lng2tile(center.lng, zoom);
        let tileY = lat2tile(center.lat, zoom);
        let currentTileUrl = getTileUrl(currentFrameUrlTemplate, zoom, tileX, tileY);
        let nextTileUrl = getTileUrl(nextFrameUrlTemplate, zoom, tileX, tileY);
        computeArrowVectors(currentTileUrl, nextTileUrl, tileX, tileY, zoom, function (geojson) {
            if (!map.getSource("arrowSource")) {
                map.addSource("arrowSource", { type: "geojson", data: geojson });
                map.addLayer({
                    id: "arrowLayer",
                    type: "symbol",
                    source: "arrowSource",
                    layout: {
                        "icon-image": "arrow-icon",
                        "icon-rotate": ["get", "direction"],
                        "icon-size": 0.025,
                        "icon-allow-overlap": true,
                        "visibility": showArrows ? "visible" : "none"
                    }
                });
            } else {
                map.getSource("arrowSource").setData(geojson);
            }
        });
    }
    function computeArrowVectors(currentTileUrl, nextTileUrl, tileX, tileY, zoom, callback) {
        let img1 = new Image();
        let img2 = new Image();
        let loadedCount = 0;
        function checkLoaded() {
            loadedCount++;
            if (loadedCount < 2) return;
            let canvas1 = document.createElement('canvas');
            let canvas2 = document.createElement('canvas');
            canvas1.width = canvas2.width = 256;
            canvas1.height = canvas2.height = 256;
            let ctx1 = canvas1.getContext('2d', { willReadFrequently: true });
            let ctx2 = canvas2.getContext('2d', { willReadFrequently: true });
            ctx1.drawImage(img1, 0, 0);
            ctx2.drawImage(img2, 0, 0);
            let gridStep = 32;
            let intensityThreshold = 50;
            let minMotionThreshold = 2;
            let arrowFeatures = [];
            for (let y = 0; y < 256; y += gridStep) {
                for (let x = 0; x < 256; x += gridStep) {
                    let width = (x + gridStep > 256) ? 256 - x : gridStep;
                    let height = (y + gridStep > 256) ? 256 - y : gridStep;
                    let imgData1 = ctx1.getImageData(x, y, width, height);
                    let imgData2 = ctx2.getImageData(x, y, width, height);
                    let data1 = imgData1.data;
                    let data2 = imgData2.data;
                    let sumIntensity = 0, sumX = 0, sumY = 0, count = 0;
                    for (let j = 0; j < height; j++) {
                        for (let i = 0; i < width; i++) {
                            let index = (j * width + i) * 4;
                            let r = data1[index], g = data1[index + 1], b = data1[index + 2];
                            let intensity = 0.3 * r + 0.59 * g + 0.11 * b;
                            sumIntensity += intensity;
                            sumX += i * intensity;
                            sumY += j * intensity;
                            count++;
                        }
                    }
                    let avgIntensity = sumIntensity / count;
                    if (avgIntensity < intensityThreshold) continue;
                    let centerX1 = sumX / sumIntensity;
                    let centerY1 = sumY / sumIntensity;
                    sumIntensity = 0; sumX = 0; sumY = 0; count = 0;
                    for (let j = 0; j < height; j++) {
                        for (let i = 0; i < width; i++) {
                            let index = (j * width + i) * 4;
                            let r = data2[index], g = data2[index + 1], b = data2[index + 2];
                            let intensity = 0.3 * r + 0.59 * g + 0.11 * b;
                            sumIntensity += intensity;
                            sumX += i * intensity;
                            sumY += j * intensity;
                            count++;
                        }
                    }
                    let centerX2 = sumX / sumIntensity;
                    let centerY2 = sumY / sumIntensity;
                    let dx = centerX2 - centerX1;
                    let dy = centerY2 - centerY1;
                    let mag = Math.sqrt(dx * dx + dy * dy);
                    if (mag < minMotionThreshold) continue;
                    let angle = Math.atan2(dy, dx) * (180 / Math.PI);
                    let pixelCenterX = x + width / 2;
                    let pixelCenterY = y + height / 2;
                    let relX = pixelCenterX / 256;
                    let relY = pixelCenterY / 256;
                    let lon = tile2lng(tileX + relX, zoom);
                    let lat = tile2lat(tileY + relY, zoom);
                    let feature = {
                        type: "Feature",
                        geometry: { type: "Point", coordinates: [lon, lat] },
                        properties: { direction: angle }
                    };
                    arrowFeatures.push(feature);
                }
            }
            let geojson = { type: "FeatureCollection", features: arrowFeatures };
            callback(geojson);
        }
        img1.crossOrigin = "anonymous";
        img2.crossOrigin = "anonymous";
        img1.src = currentTileUrl + '?cacheBust=' + Date.now();
        img2.src = nextTileUrl + '?cacheBust=' + Date.now();
        img1.onload = checkLoaded;
        img2.onload = checkLoaded;
    }
</script>
