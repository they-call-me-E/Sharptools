<!-- Do not edit below -->
<script type="application/json" id="tile-settings">
{
  "schema": "0.2.0",
  "settings": [
    {"name": "mToken", "label": "Mapbox Access Token", "type": "STRING"},
    {"type": "STRING", "name": "mLat", "label": "Map Zone Latitude "},
    {"type": "STRING", "name": "mLon", "label": "Map Zone Longitude "},
    {
      "name": "mZoom",
      "label": "Map Zone Zoom Level (0-22) 0 = Zoomed Out, 22 = Zoomed In",
      "type": "NUMBER"
    },
    {"type": "NUMBER", "name": "wStyle", "label": "Weather Style (0-11)"},
    {
      "type": "NUMBER",
      "name": "mStyle",
      "label": "Map Style (1: Streets, 2: Light, 3: Dark, 4: Satellite)"
    },
    {"type": "STRING", "name": "statesAlerts", "label": "NC  or NC,SC,GA,TN"}
  ],
  "name": "Rain Viewer",
  "dimensions": {"height": 3, "width": 3}
}
</script>
<!-- Do not edit above -->

<style>
    /* MAPBOX AND LAYOUT STYLES */
    .mapboxgl-ctrl-attrib.mapboxgl-compact {
        display: none !important;
    }

    .mapboxgl-ctrl {
        display: none !important;
    }

    #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
        left: 0;
    }

    /* Removed legendButton and legendPopup styles */

    #animationProgress {
        position: absolute;
        left: 80px;
        bottom: 25px;
        height: 6px;
        width: calc(100% - 170px);
        background-color: #ccc;
        border-radius: 3px;
        z-index: 10;
    }

    #progressDot {
        position: absolute;
        top: 50%;
        width: 12px;
        height: 12px;
        background-color: grey;
        border-radius: 50%;
        transform: translateY(-50%);
    }

    .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
    }

    .legend-color {
        width: 20px;
        height: 20px;
        margin-right: 5px;
        border: 1px solid #000;
    }

    .mapboxgl-popup-content {
        color: black;
        background-color: rgba(0, 0, 0, 0.7);
        border-radius: 6px;
        padding: 8px;
    }

    .popup-divider {
        margin: 8px 0;
        border: none;
        border-top: 1px solid #ccc;
    }

    .popup-description {
        display: none;
        max-height: 100px;
        overflow-y: auto;
        margin-top: 4px;
    }

    .popup-more-link {
        float: right;
        cursor: pointer;
        color: blue;
        text-decoration: underline;
        margin-top: 5px;
    }

    /* NEW: Time display overlay style */
    #timeDisplay {
        position: absolute;
        bottom: 10px;
        right: 10px;
        padding: 5px 10px;
        border-radius: 3px;
        font-family: Arial, sans-serif;
        font-size: 16px;
        z-index: 10;
    }

    /* NEW: Spinner overlay style */
    #spinner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 20;
        width: 50px;
        height: 50px;
        border: 8px solid #f3f3f3;
        border-top: 8px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }


    @keyframes spin {
        0% {
            transform: translate(-50%, -50%) rotate(0deg);
        }

        100% {
            transform: translate(-50%, -50%) rotate(360deg);
        }
    }

    /* FANCY PLAY/PAUSE BUTTON STYLES */
    .play,
    .play::before,
    .play::after {
        width: 100px;
        height: 100px;
        transition: 0.15s ease;
    }

    .play {
        overflow: hidden;
        position: absolute;
        bottom: -20px;
        left: 0;
        border-radius: 25px;
        transform: scale(0.25) translate(-32px, 0px) rotate(120deg) skewY(30deg) scaleX(0.866);
        transition: 0.35s cubic-bezier(0.5, 2, 0.7, 1);
    }

    .play:active {
        transform: scale(0.25) translate(-22px, 0px) rotate(120deg) skewY(30deg) scaleX(0.606) scaleY(0.7);
    }

    .play::before,
    .play::after {
        content: "";
        position: absolute;
        background: white;
        cursor: pointer;
    }

    .play::before {
        border-radius: 25px 25px 25px 50px;
        transform: scaleX(1.1555) skewY(-30deg) rotate(-30deg) translate(-24px, -42px) skewX(30deg) scaleY(0.8666);
    }

    .play::after {
        border-radius: 25px 25px 50px 25px;
        transform: scaleX(1.1555) skewY(-30deg) rotate(-30deg) translate(24px, -42px) skewX(-30deg) scaleY(0.8666);
    }

    .play.paused {
        transform: scale(0.25) translate(-7px, 0px) rotate(90deg) skewY(0deg) scaleX(1);
        cursor: pointer;
    }

    .play.paused:active {
        transform: scale(0.25) translate(-7px, 0px) rotate(90deg) skewY(0deg) scale(0.7);
    }

    .play.paused::before {
        height: 85px;
        width: 30px;
        transform: scale(1) skewY(0deg) rotate(-90deg) translate(21px, 35px) skewX(0deg);
        border-radius: 10px;
    }

    .play.paused::after {
        height: 85px;
        width: 30px;
        transform: scale(1) skewY(0deg) rotate(-90deg) translate(-21px, 35px) skewX(0deg);
        border-radius: 10px;
    }

    /* === NEW: Slide-in Menu Styles === */
    #menuButton {
        position: fixed;
        top: 10px;
        right: 20px;
        z-index: 60;
        background: white;
        border: none;
        cursor: pointer;
        padding: 0px;
        border-radius: 3px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    #menuButton svg {
        width: 24px;
        height: 24px;
        fill: black;
    }

    #sideMenu {
        position: fixed;
        top: 0;
        right: 0;
        width: 250px;
        max-height: 100vh;
        background: white;
        color: black;
        box-shadow: -2px 0 5px rgba(0, 0, 0, 0.3);
        transform: translateX(100%);
        transition: transform 0.3s ease;
        z-index: 50;
        padding: 20px;
        padding-bottom: 40px;
        overflow-y: auto;
        box-sizing: border-box;
    }

    #sideMenu.open {
        transform: translateX(0);
    }

    #sideMenu h3 {
        margin-top: 0;
        margin-bottom: 15px;
    }

    #sideMenu h4 {
        margin-bottom: 10px;
    }

    /* Added id="alertTitle" so we can hide/show it */
    #alertTitle {
        display: block;
    }

    #sideMenu label {
        display: block;
        margin-bottom: 10px;
        font-size: 16px;
    }

    #sideMenu button {
        display: none;
    }
</style>

<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1,maximum-scale=1">
<!-- Mapbox GL JS v2.x -->
<script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
<script src="//cdn.sharptools.io/js/custom-tiles.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<!-- === NEW: Menu Button and Side Menu Markup === -->
<button id="menuButton" title="Layers">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M3 13h18v-2H3v2zm0 4h18v-2H3v2zm0-10v2h18V7H3z"></path>
    </svg>
</button>
<div id="sideMenu">
    <h3>Menu</h3>
    <label><input type="checkbox" id="menuCounties" checked=""> Counties</label>
    <!-- New Alerts toggle -->
    <label><input type="checkbox" id="menuAlerts" checked=""> Alerts</label>
    <!-- Use an id for the heading so it can be hidden -->
    <h4 id="alertTitle">Alert Types</h4>
    <div id="alertFilters"></div>
</div>

<div id="map"></div>
<!-- Spinner overlay; visible until preloading is complete -->
<div id="spinner"></div>
<!-- Fancy play/pause button -->
<div class="play" id="playPauseBtn"></div>
<!-- Time display overlay -->
<div id="timeDisplay"></div>
<!-- Animation progress bar -->
<div id="animationProgress">
    <div id="progressDot"></div>
</div>




<script>
    /* NOAA ALERT COLORS */
    const ALERT_COLORS = {
        "Tornado Warning": "red",
        "Severe Thunderstorm Warning": "orange",
        "Flash Flood Warning": "darkgreen",
        "Hurricane Warning": "purple",
        "Tropical Storm Warning": "blue",
        "Tornado Watch": "yellow",
        "Severe Thunderstorm Watch": "yellow",
        "Hurricane Watch": "plum",
        "Tropical Storm Watch": "lightblue",
        "Flood Warning": "darkgreen",
        "Flood Watch": "lightgreen",
        "Coastal Flood Warning": "teal",
        "Coastal Flood Watch": "lightseagreen",
        "Winter Storm Warning": "pink",
        "Winter Storm Watch": "lightpink",
        "Blizzard Warning": "white",
        "Wind Chill Warning": "lightblue",
        "High Wind Warning": "brown",
        "Wind Advisory": "tan",
        "Heat Advisory": "orange",
        "Excessive Heat Warning": "darkorange",
        "Fire Weather Warning": "red",
        "Special Marine Warning": "blue",
        "Air Quality Alert": "gray",
        "Special Weather Statement": "lightgray",
        "default": "gray"
    };
    const stateNameToAbbr = {
        "Alabama": "AL",
        "Alaska": "AK",
        "Arizona": "AZ",
        "Arkansas": "AR",
        "California": "CA",
        "Colorado": "CO",
        "Connecticut": "CT",
        "Delaware": "DE",
        "District of Columbia": "DC",
        "Florida": "FL",
        "Georgia": "GA",
        "Hawaii": "HI",
        "Idaho": "ID",
        "Illinois": "IL",
        "Indiana": "IN",
        "Iowa": "IA",
        "Kansas": "KS",
        "Kentucky": "KY",
        "Louisiana": "LA",
        "Maine": "ME",
        "Maryland": "MD",
        "Massachusetts": "MA",
        "Michigan": "MI",
        "Minnesota": "MN",
        "Mississippi": "MS",
        "Missouri": "MO",
        "Montana": "MT",
        "Nebraska": "NE",
        "Nevada": "NV",
        "New Hampshire": "NH",
        "New Jersey": "NJ",
        "New Mexico": "NM",
        "New York": "NY",
        "North Carolina": "NC",
        "North Dakota": "ND",
        "Ohio": "OH",
        "Oklahoma": "OK",
        "Oregon": "OR",
        "Pennsylvania": "PA",
        "Rhode Island": "RI",
        "South Carolina": "SC",
        "South Dakota": "SD",
        "Tennessee": "TN",
        "Texas": "TX",
        "Utah": "UT",
        "Vermont": "VT",
        "Virginia": "VA",
        "Washington": "WA",
        "West Virginia": "WV",
        "Wisconsin": "WI",
        "Wyoming": "WY",
        "Puerto Rico": "PR"
    };

    /* ANIMATION VARIABLES */
    const ANIMATION_INTERVAL_MS = 1500; // time between frames
    const FADE_DURATION_MS = 150;         // crossfade duration
    const INITIAL_FADE_MS = 600;          // initial fade-in time

    /* MAP + RADAR SETUP VARIABLES */
    let mLat = 35;
    let mLon = -83;
    let mZoom = 5;
    let radarFrames = [];
    let radarFrameTimes = []; // store timestamps for each frame
    let currentFrameIndex = 0;
    let mToken;
    let wStyle = 1;
    let mStyle = "mapbox://styles/mapbox/dark-v11";
    let stateAlerts = "NC";
    let map;

    // Global toggle variables
    let showCounties = true;
    let showAlerts = false; // default is true so alerts are visible initially
    let alertLayerIds = [];

    // Global object to filter alert types (all keys from ALERT_COLORS except "default")
    const alertTypeFilters = {};
    Object.keys(ALERT_COLORS).forEach(key => {
        if (key !== "default") { alertTypeFilters[key] = true; }
    });

    let isPlaying = false;
    let activeBuffer = "A";
    let autoPlay = true; // Prevent auto play by default

    const END_OF_LOOP_PAUSE_MS = 2000;
    let pauseActive = false;
    let pauseStartTime = 0;
    let framesLoadedCount = 0;
    let animationInterval; // to store the setInterval ID

    stio.ready((data) => {
        if (data.settings.mToken) {
            mToken = data.settings.mToken;
            if (typeof data.settings.mLat === 'string') mLat = parseFloat(data.settings.mLat);
            if (typeof data.settings.mLon === 'string') mLon = parseFloat(data.settings.mLon);
            if (isNaN(mLat) || isNaN(mLon)) {
                console.error('Error: Invalid lat/lon');
                return;
            }
            mZoom = data.settings.mZoom || mZoom;
            wStyle = data.settings.wStyle || wStyle;
            stateAlerts = data.settings.statesAlerts || stateAlerts;
            if (data.settings.mStyle == 1) mStyle = "mapbox://styles/mapbox/streets-v12";
            if (data.settings.mStyle == 2) mStyle = "mapbox://styles/mapbox/light-v11";
            if (data.settings.mStyle == 3) mStyle = "mapbox://styles/mapbox/dark-v11";
            if (data.settings.mStyle == 4) mStyle = "mapbox://styles/mapbox/satellite-v9";
            mapboxgl.accessToken = mToken;
            initializeMap();
            buildAlertFilters();
        }
    });

    /** Build alert filters checkboxes **/
    function buildAlertFilters() {
        const container = document.getElementById('alertFilters');
        container.innerHTML = '';
        Object.keys(alertTypeFilters).forEach(alertType => {
            const label = document.createElement('label');
            label.style.display = 'block';
            label.style.marginBottom = '8px';
            label.style.fontSize = '14px';
            label.style.verticalAlign = 'middle';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = alertTypeFilters[alertType];
            checkbox.setAttribute('data-type', alertType);
            checkbox.style.verticalAlign = 'middle';
            checkbox.addEventListener('change', (e) => {
                const type = e.target.getAttribute('data-type');
                alertTypeFilters[type] = e.target.checked;
                removeAllAlertLayers();
                if (showAlerts) { fetchNoaaAlerts(); }
            });
            label.appendChild(checkbox);
            const colorBox = document.createElement('span');
            colorBox.style.width = '16px';
            colorBox.style.height = '16px';
            colorBox.style.display = 'inline-block';
            colorBox.style.backgroundColor = ALERT_COLORS[alertType] || 'transparent';
            colorBox.style.margin = '0 5px';
            colorBox.style.verticalAlign = 'middle';
            label.appendChild(colorBox);
            label.appendChild(document.createTextNode(alertType));
            container.appendChild(label);
        });
    }

    /** Initialize Map, load data, preload frames **/
    async function initializeMap() {
        map = new mapboxgl.Map({
            container: "map",
            style: mStyle,
            center: [mLon, mLat],
            zoom: mZoom
        });
        new mapboxgl.Marker().setLngLat([mLon, mLat]).addTo(map);

        map.on('moveend', () => {
            console.log('Moving map');
            //const visibleStates = getVisibleStateAbbreviations();
            //console.log('Visible States:', visibleStates);
            const closestAbbrs = getClosestStateAbbreviations(3); // Change 3 to 1-4 as desired.
            console.log("Closest state abbreviations:", closestAbbrs.join(', '));
            // Update the global stateAlerts variable with the closest states
            stateAlerts = closestAbbrs.join(',');

            // Optionally remove previously drawn alerts (currently commented out)
            removeAllAlertLayers();

            // Fetch new alerts based on the updated stateAlerts
            fetchNoaaAlerts();
        });

        map.on("load", async () => {
            addStatesLayer();
            if (showCounties) { addCountiesLayer(); }

            await fetchRadarData();
            await fetchNoaaAlerts();
            preloadAllFrames(radarFrames, () => {
                console.log("All frames preloaded. Ready to animate.");
                document.getElementById("spinner").style.display = "none";
                setupBuffers();
                map.once("idle", () => {
                    fadeLayerIn("radarLayerA", INITIAL_FADE_MS);
                    updateTimeDisplay(currentFrameIndex);
                    const closestAbbrs = getClosestStateAbbreviations(3); // Change 3 to 1-4 as desired.
                    console.log("Closest state abbreviations:", closestAbbrs.join(', '));
                });
                if (autoPlay) { animateRadar(); }
            });
            setInterval(fetchRadarData, 300000);
        });
    }

    // Play/Pause button event listener
    const playPauseBtn = document.getElementById('playPauseBtn');
    playPauseBtn.addEventListener('click', () => {
        if (playPauseBtn.classList.contains('paused')) {
            playPauseBtn.classList.remove('paused');
            autoPlay = true;
            if (!animationInterval) { animateRadar(); }
        } else {
            playPauseBtn.classList.add('paused');
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }
    });

    // Alerts toggle event listener
    document.getElementById('menuAlerts').addEventListener('change', (e) => {
        showAlerts = e.target.checked;
        const alertTitle = document.getElementById('alertTitle');
        const alertFilters = document.getElementById('alertFilters');
        if (showAlerts) {
            alertTitle.style.display = 'block';
            alertFilters.style.display = 'block';
            fetchNoaaAlerts();
        } else {
            alertTitle.style.display = 'none';
            alertFilters.style.display = 'none';
            removeAllAlertLayers();
        }
    });

    /** Fetch Radar Data from RainViewer **/
    async function fetchRadarData() {
        try {
            const url = "https://api.rainviewer.com/public/weather-maps.json?past_hours=6";
            const response = await fetch(url);
            const apiData = await response.json();

            // Map the past frames.
            const pastFrames = apiData.radar.past.map(frame =>
                `${apiData.host}${frame.path}/256/{z}/{x}/{y}/${wStyle}/1_1.png`
            );
            const pastFrameTimes = apiData.radar.past.map(frame => frame.time);

            // Map the nowcast frames.
            const nowcastFrames = apiData.radar.nowcast.map(frame =>
                `${apiData.host}${frame.path}/256/{z}/{x}/{y}/${wStyle}/1_1.png`
            );
            const nowcastFrameTimes = apiData.radar.nowcast.map(frame => frame.time);

            // Combine both arrays.
            radarFrames = pastFrames.concat(nowcastFrames);
            radarFrameTimes = pastFrameTimes.concat(nowcastFrameTimes);

            console.log("Radar frames loaded:", radarFrames.length);
        } catch (err) {
            console.error("Error fetching radar data:", err);
        }
    }


    /** Preload all frames using <img> objects **/
    function preloadAllFrames(urls, onComplete) {
        if (!urls.length) { onComplete(); return; }
        framesLoadedCount = 0;
        urls.forEach((url) => {
            const img = new Image();
            img.src = url + `?preload=${Date.now()}`;
            img.onload = () => {
                framesLoadedCount++;
                if (framesLoadedCount === urls.length) { onComplete(); }
            };
            img.onerror = () => {
                framesLoadedCount++;
                if (framesLoadedCount === urls.length) { onComplete(); }
            };
        });
    }

    /** Setup buffers A and B at 0 opacity **/
    function setupBuffers() {
        if (radarFrames.length) {
            createRadarLayer("radarSourceA", "radarLayerA", radarFrames[0], 0);
        }
        createRadarLayer("radarSourceB", "radarLayerB",
            radarFrames.length ? radarFrames[0] : "", 0);
        updateProgressBar(0);
    }

    /** Create a raster source and layer **/
    function createRadarLayer(sourceId, layerId, tileUrl, initOpacity) {
        if (map.getLayer(layerId)) { map.removeLayer(layerId); }
        if (map.getSource(sourceId)) { map.removeSource(sourceId); }
        if (!tileUrl) return;
        map.addSource(sourceId, {
            type: 'raster',
            tiles: [tileUrl],
            tileSize: 256,
            minzoom: 0,
            maxzoom: 12
        });
        map.addLayer({
            id: layerId,
            type: 'raster',
            source: sourceId,
            paint: { 'raster-opacity': initOpacity }
        });
    }

    /** Fade a layer from 0 to 1 opacity **/
    function fadeLayerIn(layerId, durationMs) {
        const startTime = performance.now();
        function step(now) {
            const elapsed = now - startTime;
            const fraction = Math.min(elapsed / durationMs, 1);
            if (map.getLayer(layerId)) {
                map.setPaintProperty(layerId, 'raster-opacity', fraction);
            }
            if (fraction < 1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
    }

    /** Main animation loop using double-buffer crossfade **/
    function animateRadar() {
        if (radarFrames.length < 2) return;
        animationInterval = setInterval(() => {
            const playPauseEl = document.getElementById('playPauseBtn');
            isPlaying = !playPauseEl.classList.contains('paused');
            if (!isPlaying) return;
            if (pauseActive) {
                if (Date.now() - pauseStartTime >= END_OF_LOOP_PAUSE_MS) {
                    pauseActive = false;
                } else {
                    return;
                }
            }
            crossfadeNextFrame();
            updateProgressBar(currentFrameIndex);
            updateTimeDisplay(currentFrameIndex);
            if (currentFrameIndex === radarFrames.length - 1) {
                pauseActive = true;
                pauseStartTime = Date.now();
            }
            currentFrameIndex = (currentFrameIndex + 1) % radarFrames.length;
        }, ANIMATION_INTERVAL_MS);
    }

    /** Crossfade to the next frame using buffers A and B **/
    function crossfadeNextFrame() {
        const oldBuf = activeBuffer;
        const newBuf = (oldBuf === "A") ? "B" : "A";
        const oldLayerId = "radarLayer" + oldBuf;
        const newLayerId = "radarLayer" + newBuf;
        const newSourceId = "radarSource" + newBuf;
        const frameUrl = radarFrames[currentFrameIndex];
        console.log(`Frame ${currentFrameIndex} => buffer ${newBuf}`, frameUrl);
        createRadarLayer(newSourceId, newLayerId, frameUrl, 0);
        map.once("idle", () => {
            fadeLayers(oldLayerId, newLayerId, FADE_DURATION_MS);
        });
        activeBuffer = newBuf;
    }

    /** Fade out the old layer while fading in the new layer **/
    function fadeLayers(layerOut, layerIn, durationMs) {
        const startTime = performance.now();
        function step(now) {
            const elapsed = now - startTime;
            const fraction = Math.min(elapsed / durationMs, 1);
            if (map.getLayer(layerOut)) {
                map.setPaintProperty(layerOut, 'raster-opacity', 1 - fraction);
            }
            if (map.getLayer(layerIn)) {
                map.setPaintProperty(layerIn, 'raster-opacity', fraction);
            }
            if (fraction < 1) requestAnimationFrame(step);
        }
        requestAnimationFrame(step);
    }

    /** Update the progress bar dot **/
    function updateProgressBar(frameIndex) {
        const progressBar = document.getElementById('animationProgress');
        const dot = document.getElementById('progressDot');
        if (!radarFrames || radarFrames.length < 2) {
            dot.style.left = '0px';
            return;
        }
        const available = progressBar.clientWidth - dot.clientWidth;
        const fraction = frameIndex / (radarFrames.length - 1);
        dot.style.left = (fraction * available) + "px";
    }

    /** Update the time display overlay with the current frame's timestamp **/
    function updateTimeDisplay(frameIndex) {
        if (radarFrameTimes.length > 0) {
            let timestamp = radarFrameTimes[frameIndex];
            let date = new Date(timestamp * 1000);
            let options = { hour: 'numeric', minute: 'numeric', hour12: true };
            let timeString = date.toLocaleTimeString([], options);
            document.getElementById("timeDisplay").textContent = timeString;
        }
    }

    /** NOAA Alerts functions **/
    async function fetchNoaaAlerts() {
        if (!showAlerts) return;

        // Show the spinner (using the existing #spinner element)
        document.getElementById('spinner').style.display = 'block';

        const alertUrl = `https://api.weather.gov/alerts/active?area=${stateAlerts}`;
        try {
            const response = await fetch(alertUrl);
            const data = await response.json();
            if (!data.features) {
                console.log("No NOAA alerts found for:", stateAlerts);
                return;
            }
            console.log("NOAA Alerts found:", data.features.length);
            for (const feature of data.features) {
                const eventType = feature.properties.event || "default";
                if (!alertTypeFilters[eventType]) continue;
                const alertColor = ALERT_COLORS[eventType] || ALERT_COLORS["default"];
                const headline = feature.properties.headline || "N/A";
                const updatedProps = { ...feature.properties, fillColor: alertColor, myHeadline: headline };
                const newFeature = { ...feature, properties: updatedProps };
                if (newFeature.geometry) {
                    addAlertPolygon(newFeature, alertColor);
                } else {
                    const zones = newFeature.properties.affectedZones || [];
                    for (const zoneUrl of zones) {
                        await fetchZoneGeometry(zoneUrl, newFeature, alertColor);
                    }
                }
            }
        } catch (err) {
            console.error("Error fetching NOAA alerts:", err);
        } finally {
            // Hide the spinner when alerts processing is complete
            document.getElementById('spinner').style.display = 'none';
        }
    }



    function addAlertPolygon(feature, color) {
        const simplifiedFeature = turf.simplify(feature, { tolerance: 0.01, highQuality: false });
        const alertId = simplifiedFeature.id || ("alert-" + Math.random());
        alertLayerIds.push(alertId);
        map.addSource(alertId, {
            type: "geojson",
            data: { type: "FeatureCollection", features: [simplifiedFeature] }
        });
        map.addLayer({
            id: alertId,
            type: "fill",
            source: alertId,
            paint: { "fill-color": color, "fill-opacity": 0.3 }
        });
        map.addLayer({
            id: alertId + "-border",
            type: "line",
            source: alertId,
            paint: { "line-color": color, "line-width": 2 }
        });
        map.on("click", alertId, (e) => {
            const props = e.features[0].properties;
            showAlertPopup(e.lngLat, props);
        });
    }

    async function fetchZoneGeometry(zoneUrl, parentFeature, color) {
        try {
            const resp = await fetch(zoneUrl);
            const data = await resp.json();
            if (!data.geometry) {
                console.log("No geometry for zone:", zoneUrl);
                return;
            }
            let zoneFeature = {
                type: "Feature",
                geometry: data.geometry,
                properties: { ...parentFeature.properties }
            };
            zoneFeature = turf.simplify(zoneFeature, { tolerance: 0.01, highQuality: false });
            const zoneId = (parentFeature.id || "alert-") + "-" + data.id;
            alertLayerIds.push(zoneId);
            map.addSource(zoneId, {
                type: "geojson",
                data: { type: "FeatureCollection", features: [zoneFeature] }
            });
            map.addLayer({
                id: zoneId,
                type: "fill",
                source: zoneId,
                paint: { "fill-color": color, "fill-opacity": 0.3 }
            });
            map.addLayer({
                id: zoneId + "-border",
                type: "line",
                source: zoneId,
                paint: { "line-color": color, "line-width": 2 }
            });
            map.on("click", zoneId, (e) => {
                const props = e.features[0].properties;
                showAlertPopup(e.lngLat, props);
            });
        } catch (err) {
            console.error("Error fetching zone geometry for", zoneUrl, err);
        }
    }

    function showAlertPopup(lngLat, props) {
        const headline = props.myHeadline || "N/A";
        const descriptionFull = props.description || "No further details provided.";
        const popupContent = document.createElement('div');
        popupContent.innerHTML = `<strong>${headline}</strong>`;
        const divider = document.createElement('hr');
        divider.className = 'popup-divider';
        divider.style.display = 'none';
        popupContent.appendChild(divider);
        const descDiv = document.createElement('div');
        descDiv.className = 'popup-description';
        descDiv.textContent = descriptionFull;
        popupContent.appendChild(descDiv);
        const toggleLink = document.createElement('span');
        toggleLink.className = 'popup-more-link';
        toggleLink.textContent = 'More';
        if (descriptionFull.trim() && descriptionFull !== 'No further details provided.') {
            toggleLink.addEventListener('click', () => {
                if (descDiv.style.display === 'none') {
                    descDiv.style.display = 'block';
                    divider.style.display = 'block';
                    toggleLink.textContent = 'Less';
                } else {
                    descDiv.style.display = 'none';
                    divider.style.display = 'none';
                    toggleLink.textContent = 'More';
                }
            });
        } else {
            toggleLink.style.display = 'none';
        }
        popupContent.appendChild(toggleLink);
        new mapboxgl.Popup().setLngLat(lngLat).setDOMContent(popupContent).addTo(map);
    }

    /* === NEW: Side Menu Functionality === */
    document.getElementById('menuButton').addEventListener('click', () => {
        document.getElementById('sideMenu').classList.toggle('open');
    });
    document.getElementById('menuCounties').addEventListener('change', (e) => {
        showCounties = e.target.checked;
        if (showCounties) {
            addCountiesLayer();
        } else {
            if (map.getLayer("counties-layer")) map.removeLayer("counties-layer");
            if (map.getSource("counties")) map.removeSource("counties");
        }
    });
    // NEW: Alerts toggle event
    document.getElementById('menuAlerts').addEventListener('change', (e) => {
        showAlerts = e.target.checked;
        const alertTitle = document.getElementById('alertTitle');
        const alertFilters = document.getElementById('alertFilters');
        if (showAlerts) {
            alertTitle.style.display = 'block';
            alertFilters.style.display = 'block';
            fetchNoaaAlerts();
        } else {
            alertTitle.style.display = 'none';
            alertFilters.style.display = 'none';
            removeAllAlertLayers();
        }
    });

    function removeAllAlertLayers() {
        alertLayerIds.forEach(id => {
            if (map.getLayer(id)) map.removeLayer(id);
            if (map.getLayer(id + "-border")) map.removeLayer(id + "-border");
            if (map.getSource(id)) map.removeSource(id);
        });
        alertLayerIds = [];
    }

    function addCountiesLayer() {
        fetch("https://raw.githubusercontent.com/they-call-me-E/Sharptools/refs/heads/main/CustomeTile/RainViewer/counties.json")
            .then(response => response.json())
            .then(countiesData => {
                if (map.getLayer("counties-layer")) map.removeLayer("counties-layer");
                if (map.getSource("counties")) map.removeSource("counties");
                map.addSource("counties", { type: "geojson", data: countiesData });
                map.addLayer({
                    id: "counties-layer",
                    type: "line",
                    source: "counties",
                    layout: {},
                    paint: {
                        "line-color": "#aaaaaa",
                        "line-width": 2,
                        "line-opacity": 0.125
                    }
                });
            })
            .catch(err => console.error("Error loading counties GeoJSON:", err));
    }
    function addStatesLayer() {
        fetch("https://raw.githubusercontent.com/they-call-me-E/Sharptools/refs/heads/main/CustomeTile/RainViewer/states.json")
            .then(response => response.json())
            .then(statesData => {
                if (map.getLayer("states-layer")) map.removeLayer("states-layer");
                if (map.getSource("states")) map.removeSource("states");
                map.addSource("states", { type: "geojson", data: statesData });
                map.addLayer({
                    id: "states-layer",
                    type: "line",
                    source: "states",
                    layout: {},
                    paint: {
                        "line-color": "#aaaaaa",
                        "line-width": 2,
                        "line-opacity": 0.5
                    }
                });
            })
            .catch(err => console.error("Error loading states GeoJSON:", err));
    }

    function getVisibleStateNames() {
        const features = map.queryRenderedFeatures({ layers: ['states-layer'] });
        const namesSet = new Set();
        features.forEach(feature => {
            if (feature.properties && feature.properties.name) {
                namesSet.add(feature.properties.name);
            }
        });
        return Array.from(namesSet).join(', ');
    }
    function getVisibleStateAbbreviations() {
        const features = map.queryRenderedFeatures({ layers: ['states-layer'] });
        const abbrSet = new Set();
        features.forEach(feature => {
            if (feature.properties && feature.properties.name) {
                const abbr = stateNameToAbbr[feature.properties.name] || feature.properties.name;
                abbrSet.add(abbr);
            }
        });
        return Array.from(abbrSet).join(', ');
    }
    function getClosestStateAbbreviations(numStates = 3) {
        // Limit numStates to a value between 1 and 4.
        numStates = Math.max(1, Math.min(numStates, 4));

        // Get the current map center as a Turf point.
        const center = map.getCenter();
        const centerPoint = turf.point([center.lng, center.lat]);

        // Retrieve all features from the "states-layer"
        const features = map.queryRenderedFeatures({ layers: ['states-layer'] });

        // Map each feature to an object containing its abbreviation and distance from the center.
        const featuresWithDistance = features.map(feature => {
            const name = feature.properties && feature.properties.name;
            if (!name) return null;
            // Get abbreviation from mapping.
            const abbr = stateNameToAbbr[name] || name;
            const centroid = turf.centroid(feature);
            const distance = turf.distance(centerPoint, centroid, { units: 'kilometers' });
            return { abbr, distance };
        }).filter(item => item !== null);

        // Deduplicate by abbreviation (keeping the one with the smallest distance)
        const uniqueStates = {};
        featuresWithDistance.forEach(item => {
            if (!uniqueStates[item.abbr] || uniqueStates[item.abbr].distance > item.distance) {
                uniqueStates[item.abbr] = item;
            }
        });

        // Sort unique states by distance and take the closest numStates.
        const sortedStates = Object.values(uniqueStates).sort((a, b) => a.distance - b.distance);
        return sortedStates.slice(0, numStates).map(item => item.abbr);
    }


</script>
